
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
  
    // Helper function to check if the requesting user is an admin.
    // It reads the 'role' field from the user's own document in the 'users' collection.
    function isAdmin(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role == 'admin';
    }

    // Rules for the 'users' collection
    match /users/{userId} {
      // READ:
      // Allow read access under two conditions:
      // 1. The requesting user is an admin.
      // 2. The requesting user is authenticated (e.g., for browsing profiles).
      allow read: if isAdmin(request.auth.uid) || request.auth != null;

      // CREATE:
      // Allow a user to create their own document if the document ID matches their auth uid.
      allow create: if request.auth != null && request.auth.uid == userId;
      
      // UPDATE, DELETE:
      // Allow a user to update or delete only their own document.
      allow update, delete: if request.auth.uid == userId;
    }

    // Rules for the 'likesReceived' collection
    match /likesReceived/{likeId} {
      // Anyone authenticated can read from this collection. This might be useful later.
      allow read: if request.auth != null;

      // CREATE:
      // A user can create a 'like' document. We can't easily verify the 'likedBy' field
      // against the UID without complex gets, so we trust the client for now, which is a common pattern.
      // The key security is that they can only delete their own likes.
      allow create: if request.auth != null;

      // DELETE:
      // A user can only delete a 'like' document they created.
      // We check if the 'likeId' string starts with their member ID, which is fetched from their user document.
      // This ensures a user can only undo their own 'like' action.
      allow delete: if request.auth != null && likeId.startsWith(get(/databases/$(database)/documents/users/$(request.auth.uid)).data.memberid);
    }
  }
}
